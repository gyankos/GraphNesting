% !TeX root = 00_nesting_paper.tex
\begin{figure}[!b]
	\centering
	\begin{minipage}[!t]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/nesting/patterns/01_preliminar_question.pdf}
		\subcaption{Comparing the vertex summarization pattern and the path summarization patterns. We suppose that edge grouping references ($\gamma_E^{src}$ and $\gamma_E^{dst}$) correspond to the same vertex appearing as a vertex grouping reference ($\gamma_V$) Such correspondence is directly marked my the user itself providing the query by drawing morphisms (correspondences) between the vertex and the path summarization patterns (red edges). The intersections between the two patterns may be directly outlined by the user itself that provides the query (blue edges, representing other morphisms).}
		\label{fig:patcomparison}
	\end{minipage} \begin{minipage}[!t]{0.45\textwidth}
		\centering
		\includegraphics[width=.8\textwidth]{images/nesting/patterns/02_edge_analysis.pdf}
		\subcaption{Path summarization pattern sharing an $\alpha$ area of common patterns shared between the patterns, which are necessairly not the edge grouping references by definition.}
		\label{fig:edgewithIntersectionNonSRC}
	\end{minipage}%\quad \begin{minipage}[!t]{0.45\textwidth}
%		\centering
%		\includegraphics[width=.8\textwidth]{images/nesting/patterns/03_edge_analysis.pdf}
%		\subcaption{Path summarization pattern not sharing a common $\alpha$ area, although $\gamma_E^{src}$ and $\gamma_E^{dst}$ must always be present in $g_E$ by hypothesis. This constraint guarantees that the newly created edge will be associated to a nested vertex originating from the vertex summarization pattern.}
%		\label{fig:edgeWithNoIntersection}
%	\end{minipage}
	\caption{Vertex  and Path  summarization patterns.}
	\label{fig:patternAnalysis}
\end{figure}
\vfill\eject

\section{Class of optimizable graph nesting queries}\label{sec:optimizableClass}
Prior to the analysis of the THoSP algorithm that is going to be provided later on in the next subsection, we want to discuss which is the class of vertex and path summarization patterns optimizable as discussed in the chapter's introduction. As we already observed, %, the comparison of several graph collections may lead to an intractable solution which is exponential in time over the graph dimension, where the exponent is the arbitrary size of the collection generated from the original graph operand. 
the exhaustive search of graph patterns in the most general scenario must be done at any rate, because the vertex and  edge subgraphs may be extracted by an external tool of which we totally ignore its behaviour. As we also discussed in the introduction, the generation of the collections is only relevant with respect to actual data that is going to be nested and, in our case, we can only nest a subgraph of the graph resulting from the graph visiting process: consequently, within each pattern we must remark which elements are going to be nested at the final result.

First, we must provide a formal characterization of the grouping reference: we want to elect a subgraph $\gamma_p$ for each graph pattern $p$ such that each graph generated by  ${g_p}(\nested)$ expose unique elements referring to $\gamma_p$. %each for each nested graph $\nested$, a \textit{grouping reference} $\gamma_p$ of a graph pattern $g_p$ elects which elements of the subgraph $g\subseteq \nested$ returned by the graphs extraction query must appear only once per returned subgraph by $m_{g_p}(\nested)$. 
These grouping references allow to elect the subcomponents that identify an entity over which the aggregation will be performed during the graph matching process. Hereby, we can provide the following formal definition for grouping references:
\begin{definition}[Grouping reference]
	Given a graph pattern $p$ generating subgraphs ${g_p}(\nested)$ over a nested graph $\nested$, a \textbf{grouping reference} $\gamma_p$ is a subpattern $\gamma_p\subseteq g_p$ restricting the possible  generated by ${g_p}(\nested)$ such that to each vertex (or edge) in $\gamma_p$ corresponds one single vertex (or edge) in $\nested$ and that $g_p(\nested)$ contains distinct graphs. Such correspondence may be denoted using a function $f_C$ for each $G_C\in g_p(\nested)$ denoted as follows:
	\[m_{g_p}(\nested)=\Set{f_C|G:C\in g_p(\nested), p \overset{f_C}{\to} G_C}\]
\end{definition}

In particular, the elements appearing in SQL's \texttt{Group By}, AQL's \texttt{COLLECT} and Cypher's \texttt{WITH} (except from the parts where the aggregation is performed) are all grouping references of our matched graphs.

In order to reduce the computational complexity of aggregating the grouping reference, we can reduce the grouping references to one single vertex for vertex summarization patterns, and to two (distinct) vertices for path summarization patterns: in the first scenario, such vertex will identify the entity over which we can perform the nesting of all the other matched contents, while for the path summarization pattern the grouping references will identify the source ($\gamma_E^{src}$) and target ($\gamma_E^{dst}$) vertices corresponding to the vertex summarization patterns' grouping references, and hereby corresponding to the final vertices that are going to be nested in the final result. Hereby, the class of our algorithms create new nested edges only over vertices that have been previously matched as grouping references and then nested. Moreover, we can choose to mark with a specific $\ell$ label (e.g. \mstr{toNest}) each vertex and edge within each pattern in order to remark which matched vertices and edges are going to be represented in the final nesting result; this implies that UDF functions are not required by such class of problems because they can be directly represented within the graph patterns.


%\hl{Research purposes, currently investigated with the research group at Leipzig University}
%\textbf{Generalization of pattern matching approaches (algorithmical enhancement)}. Current graph query languages perform matches of different $G_H$ separately, while it can be beneficial to visit all the common subpatterns only once, and not $k$ times, thus reducing the visiting complexity from $|g|^k$ to $|g|$, where $|g|$ is the common subgraph. The application of chained generalized graph grammar rules must be done efficiently without repeating some visiting tasks more than once. The target is to find the subgraphs commonly shared by several matching strategies, whenever is possible (e.g. graph nesting as introduced in the previous chapter.)
%\textbf{Overcoming to Cypher limitations}. This algorithmical assumption implies that we do not need to extend Cypher to support nestings for some simple graph pattern matching tasks. 

Figure \ref{fig:patternAnalysis} provides an example on how  graph nesting queries based on grouping references can be optimized for both vertex ($g_V$) and path ($g_E$) summarization queries: given that the users are going to provide both the vertex and the path summarization queries, such users must directly draw the correspondences between vertex and edge pattern queries, so that the correspondences can be promptly  identified by the query plan which can better optimize the whole query execution (Figure \ref{fig:patcomparison}). After doing so, we can start to perform the general graph visiting algorithm for graph nesting (Algorithm \ref{alg:general}) by detecting which regions of both patterns are shared together in $\alpha=g_V\cap g_E$ (Figure \ref{fig:edgewithIntersectionNonSRC}); given that source and destination vertices in path summarization patterns' grouping references are distinct by definition, source and destination vertices may not be represented in $\alpha$ (Algorithm \ref{alg:general}, line \ref{obtainAlpha}). Consequently, in order to reduce the graph visiting process, we can first perform pattern matching over the input graph over $\alpha$, thus allowing a partial instantiation of the $g_V$ and $g_E$ patterns, and then iteratively extend the nesting information after each visit of $\alpha$ and  its own refinements. In particular, we can perform the algorithm  as follows:
\begin{algorithm}[!t]
	\caption{Grouping Reference Optimizable Queries (GROQ)}\label{alg:general}
	\algrenewcommand\algorithmicindent{0.5em}
	\begin{adjustbox}{max width=\textwidth}
		\begin{minipage}{1.2\linewidth}
			\begin{algorithmic}[1]
				\Procedure{GROQ}{$(g_V,\gamma_V),({g_E},\gamma_E^{src},\gamma_E^{dst}),m;\;\nested$}:
				\State {$\alpha:=g_V\cap {g_E}\backslash(\gamma_V\cup\gamma_E)$;}\label{obtainAlpha}
				\State {lV $:=$ [];}
				\If{$\alpha\neq\emptyset$}
				\For {\textbf{each graph} $g^i$ generated from $m_\alpha(\nested)$ }\label{eachAlpha}
				\State {lV $:=\{f_i\in m_{g_V;\gamma_V}(\nested)|f_i(\alpha)=g^i\}$}
				\State {GROQ$\alpha$}{($(g_V,\gamma_V),({g_E},\gamma_E^{src},\gamma_E^{dst}),m;\;\textup{lV},\nested$)}
				\EndFor
				\Else
				\State {lV $:=m_{g_V;\gamma_V}(\nested)$}\label{complete}
				\State {GROQ$\alpha$}{($(g_V,\gamma_V),({g_E},\gamma_E^{src},\gamma_E^{dst}),m;\;\textup{lV},\nested$)}
				\EndIf
				
				\EndProcedure
				\State
				\Procedure{GROQ$\alpha$}{$(g_V,\gamma_V),({g_E},\gamma_E^{src},\gamma_E^{dst}),m;\;\textup{lV},\nested$}
				\For {\textbf{each morphism} $f_i\in\; $lV}
				\State {$\{(c,i)\}:=f_i(\gamma_V)$}\label{vertexReferencePatt}
				\State {$ \omega(c+1,i)=\omega(c,i);\quad \ell(c+1,i)=\ell(c,i)$}\label{vertexLVPreserve}
				\State {$\nu(c+1,\ngraph):=\nu(c+1,\ngraph)\cup \{(c+1,i)\}$}\label{vertexGeneration}
				\State {$\nu(c+1,i):=\nu(c+1,i)\cup\Set{f_i(o)|o\in V\cap\mathcal{V},\mstr{toNest}\in\ell(o)}$}\label{vertexContent1}
				\State {$\epsilon(c+1,i):=\epsilon(c+1,i)\cup\Set{f_i(o)|o\in V\cap\mathcal{E},\mstr{toNest}\in\ell(o)}$}\label{vertexContent2}
				\EndFor
				\For {\textbf{each morphism} $f_i,f_j\in\; $lV}
				\State{lE $:=\{f_k\in m_{{g_E};\gamma_E^{src},\gamma_E^{dst}}(\nested)|f_i(\gamma_V)=f_k(\gamma_E^{src}),f_j(\gamma_V)=f_k(\gamma_E^{dst})\}$}\label{fulTraverse}
				\For {\textbf{each morphism} $f_k\in\; $lE}
				\State {$\{(c,s)\}:=f_i(\gamma_E^{src})$;\qquad $\{(c,d)\}:=f_i(\gamma_E^{dst})$}\label{pathReferencePatt1}
				\State {$j:=dt(s,d)$}\label{pathReferencePatt2}
				\State {$\omega(c+1,j):=\omega(c,s)\cup\omega(c,d);\; \xi(i_{c+1}):=\xi(i_c)\cup\ell(d_c)$}\label{fromNewElements}
				\State {$\epsilon(c+1,j):=\epsilon(c+1,j)\cup f_k(\gamma_V)$}\label{edgeGeneration}
				\State {$\lambda(c+1,j):=(({c+1},s),({c+1},d))$}
				\State {$\nu(c+1,j):=\nu(c+1,j)\cup\Set{f_k(o)|o\in E\cap \mathcal{V},\mstr{toNest}\in\ell(o))}$}
				\State {$\epsilon(c+1,j):=\epsilon(c+1,j)\cup\Set{f_k(o)|o\in E\cap\mathcal{E},\mstr{toNest}\in\ell(o)}$}
				\EndFor
				\EndFor
				\EndProcedure
				
			\end{algorithmic}
		\end{minipage}
	\end{adjustbox}
\end{algorithm}

\begin{itemize}
	\item Given a nested graph classifier $g$ for graph pattern languages, we extract all the subgraphs $g^i$ of $\nested$ generated by  $g_\alpha(\nested)$, when $\alpha$ is not empty (line \ref{eachAlpha}). If $\alpha$ is otherwise an empty pattern, we must necessarily perform a complete visit of the vertex patterns $g_V$, and perform complete instantiations of such patterns (line \ref{complete}). 
	\item We can iteratively construct the nested graph without knowing the complete information by relying on the ids of the expected elements, and we can provide the greatest subgraph of $g$ matching $\alpha$  after visiting  each possible $\alpha$ matching result, represented as a correspondence $f_i$. For this reason, the GROQ$\alpha$ subroutine may be called in both cases.
	
	\item After providing a partial instantiation of the vertex summarization patterns via $\alpha$, we find a vertex $(c,i)$ matching the grouping reference $\gamma_V$ to which we are going to nest the remaining objects: from $(c,i)$ we generate a newly derived vertex $({c+1},i)$ %start to generate a new nested vertex: this new vertex $i_{c+1}$ descends from the object $(c,i)$ matched by the grouping reference $\gamma_V$ 
	(line \ref{vertexReferencePatt}) preserving all the labels and tuples (line \ref{vertexLVPreserve}). The nesting content of $({c+1},i)$ derives from the partial instantiation of the correspondence $f_i$, by choosing the vertices and edges in $\nested$ which corresponds to vertex summarization objects marked with \mstr{toNest} (lines \ref{vertexContent1} and \ref{vertexContent2}).
	
	\item At this point we can use the same semi-instantiated correspondence in \texttt{lV} from $\alpha$ to partially instantiate the path summarization pattern, that  is now going to be fully traversed (line \ref{fulTraverse}). For each of these $f_i$ instantiations, new edges are going to be generated, inheriting the labels and tuples from the matched edges grouping references, $(c,s)$ and $(c,d)$. In particular, we can directly create associate to such edge the soruces and the targets represented by nested vertices, which will respectively be $(c+1,s)$ and $({c+1},d)$.
	
	\item The procedure is iterated until the whole graph is not visited via subsequent correspondences, and hence all the matched elements are associated from the objects $({c+1},i)$ (either vertices or edges) generated from the ones matched by the grouping reference $(c,i)$.
\end{itemize}

As we can see from the algorithm, the advantage of this approach is that the graph $g^i$ and the instantiated correspondences (as a consequence of the graph matching phase) are promptly used to define the nested information (e.g., lines \ref{vertexGeneration}-\ref{vertexContent2}). It is evident that the aforementioned algorithm provides the best performances when $\gamma_E^{src}$ and $\gamma_E^{dst}$ are separated by  one edge distance in $\alpha$   and both $g_V$ and $g_E$ create graph collections that are partitions of $\nested$. On the other hand, this class of algorithms was already discussed in literature and, consequently, an approach describing how to optimize such  scenarios can be already found in literature \cite{JunghannsPR17}. Nevertheless, this chapter focuses on another types of algorithms, which are the ones where $\alpha$ contains two edges and one vertex; this class of problems, to the best of our knowledge, has not been discussed yet in current literature with respect to their optimizations. %Therefore, the next paragraph is going to introduce one specific algorithm for $\alpha\neq\emptyset$, where in particular $\alpha$ is formed by one single vertex.
%Please note that, when $\alpha=\emptyset$, the computational complexity of the algorithm may easily become quadratic ($|\nu(\ngraph)|+|\nu(\ngraph)|^2$).

